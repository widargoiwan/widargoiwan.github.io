<!DOCTYPE html>
<html
  class=""
  lang="en-us"
  prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"
>
  <head>
    <meta charset="utf-8" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="description" content="" />
<meta name="HandheldFriendly" content="True" />
<meta name="MobileOptimized" content="320" />
<meta name="viewport" content="width=device-width, initial-scale=1" />


<meta name="keywords" content="">


<meta property="og:type" content="article" />
<meta property="og:description" content="" />
<meta property="og:title" content="The Entity-Relationship (ER) Model" />
<meta property="og:site_name" content="widargo" />
<meta property="og:image" content="" />
<meta property="og:image:type" content="image/jpeg" />
<meta property="og:image:width" content="" />
<meta property="og:image:height" content="" />
<meta property="og:url" content="https://widargoiwan.github.io/posts/er/" />
<meta property="og:locale" content="en-us" />
<meta property="article:published_time" content="2019-09-10
" /> <meta property="article:modified_time" content="2019-09-10
" />






    <title>The Entity-Relationship (ER) Model</title>
    <link rel="canonical" href="https://widargoiwan.github.io/posts/er/" />


    <link
  rel="stylesheet"
  href="https://unpkg.com/tachyons@4.11.1/css/tachyons.min.css"
/>

<link rel="stylesheet" href="https://widargoiwan.github.iocss/style.css" />

<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/highlightjs@9.12.0/styles/github-gist.css"
/>

<script src="https://kit.fontawesome.com/d3737c8002.js"></script>



    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
  </head>

<body
  lang="en-us"
  class="sans-serif w-90 w-60-ns center center-ns mv2 mv5-ns"
  itemscope
  itemtype="http://schema.org/Article"
>
  
  <span class="b">/ </span>
  <a
    href="https://widargoiwan.github.io"
    class="b bb bw1 pb1 no-underline black"
    >widargo</a
  >

  <span class="b">/ </span>
  <a
    href="../"
    class="b bb bw1 pb1 no-underline black"
    >posts</a
  >

  <section id="main" class="mt5">
    <h1 itemprop="name" id="title">The Entity-Relationship (ER) Model</h1>
    <span class="f6 gray">September 10, 2019</span>

    <article itemprop="articleBody" id="content" class="w-90 lh-copy">
      

<script src="//yihui.name/js/math-code.js"></script>
<!-- Just one possible MathJax CDN below. You may use others. -->
<script async
  src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<p>The task of creating a database application begins with the needs of the target users. For small applications it is feasible for a database designer who understand the applications to decide directly on the relations that are created, their attributes, and their constraints. Such a direct design process is difficult for real-world applications because they are often highly complex.</p>

<p>The database design process must then be split into several phases.</p>

<ol>
<li>The initial phase characterises fully the data needs of prospective database users.</li>
<li>The conceptual-design phase provides a detailed overview of the enterprise. The entity-relationship (ER) model is used to represent conceptual design.</li>
<li>A fully-developed conceptual schema indicates the functional requirements of the enterprise. In a specification of functional requirements, users describe the kinds of transactions/operations that are performed on the data. The database designer then reviews the conceptual schema to check if it meets functional requirements.</li>
<li>The process of moving from an abstract data model to the implementation of the database proceeds in two final design phases.</li>
</ol>

<h3 id="conceptual-design-phase">Conceptual design phase</h3>

<p>The conceptual schema specifies the entities that are represented in the database, the attributes of those entities, and the relationships.</p>

<p>The conceptual-design phase typically results in the creation of an ER diagram that provides a <em>graphic representation</em> of the database&rsquo;s schema.</p>

<h3 id="logical-design-phase">Logical design phase</h3>

<p>In the logical-design phase, the designer maps the high-level conceptual schema onto the implementation data model of the database system that is used. The implementation data model is the relational data model. This step usually consists simply of mapping the conceptual schema defined with the ER model into a relation schema defined by relational algebra.</p>

<p>The resulting system-specific database schema is then implemented using SQL. The physical features of the database are specified.</p>

<h2 id="pitfalls">Pitfalls</h2>

<p>When designing databases, we must ensure that two major pitfalls are avoided.</p>

<ol>
<li>Redundancy: a bad design repeats information. Redundancy can occur in relational schema. The biggest problem with redundant representation of information is that copies of a piece of information may become inconsistent if the information is updated without taking precautions to update all copies of the information.</li>
<li>Incompleteness: a bad design may make certain aspects of the enterprise difficult or impossible to model.</li>
</ol>

<h2 id="entity-relationship-model">Entity-Relationship Model</h2>

<p>The Entity-Relationship or ER model was developed to facilitate database design by allowing specification of an enterprise schema that represents the overall logical structure of a database.</p>

<p>The ER data model consists of three basic concepts:</p>

<ol>
<li>Entity sets</li>
<li>Relationship sets</li>
<li>Attributes</li>
</ol>

<h2 id="entity-sets">Entity sets</h2>

<p>An <em>entity</em> is a thing or object in the real world that is distinct from other objects. An entity has a set of properties, and the values for some set of properties may uniquely identify an entity. An <em>entity set</em> is a set of entities of the same type that share the same properties (or attributes). For example, the set of all people who are instructors at a given university can be defined as the entity set <em>instructor</em>.</p>

<p>An entity is represented by a set of <em>attributes</em>. Attributes are descriptive properties possessed by every member of an entity set. The designation of an attribute for an entity set expresses that the database stores similar information concerning each entity in the entity set. However, each entity may have its own value for each attribute. Each entity has a <em>value</em> for each of its attributes. The domain of the attribute is its type. A database includes a collection of entity sets, each of which contains any number of entities of the same type.</p>

<h3 id="weak-entity-sets">Weak entity sets</h3>

<p>A weak entity set is an entity set that does not have sufficient attributes to form a primary key. An entity set that <em>has a primary key</em> is termed a strong entity set. For a weak entity set to be meaningful, it must be associated with another entity set called the identifying or owner entity set.</p>

<p>Every weak entity must be associated with an identifying entity. The weak entity set is thus said to be <em>existence dependent</em> on the identifying entity set. The identifying entity set owns the weak entity set that it identifies. The relationship associating the weak entity set with the identifying entity set is known as the identifying relationship.</p>

<p>The identifying relationship is many-to-one from the weak entity set to the identifying entity set, and the participation of the weak entity set in the relationship is <em>total.</em></p>

<p>The <em>partial key</em> of a weak entity set is a set of attributes of the eak entity set that uniquely identifies a weak entity for a given owner entity, that is, since a weak entity&rsquo;s existence is dependent on the existence of the owner entity.</p>

<h4 id="identifying-weak-entity-sets">Identifying weak entity sets</h4>

<p>Although a weak entity set does not have a primary key, we need a means of distinguishing among all those entities in the weak entity set that depend on one particular strong entity. The <em>discriminator</em> of a weak entity set is a set of attributes that allows this distinction to be made.</p>

<p>This unique combination of attributes allows us to uniquely identify each entry in the weak entity set. The discriminator of the weak entity set is also known as the <em>partial key</em> of the entity set.</p>

<ul>
<li>The discriminator of a weak entity set is underlined with a dashed rather than solid line.</li>
<li>The relationship set connecting the weak entity set to the identifying strong entity is depicted by a double diamond.</li>
</ul>

<h3 id="relationship-sets">Relationship sets</h3>

<p>A relationship is an association among several entities. A relationship set is a set of relationships of the same type. Formally, it is a mathematical relation on n &gt;= 2 (possibly non-distinct) entity sets.</p>

<p>$${(e_1, e_2, \dots, e_n) | e_1 \in E_1, e_2 \in E_2, \dots, e_n \in E_n}$$</p>

<p>The association between entity sets is referred to as participation. Thus, the entity sets $E_1, E_2, \dots, E_n$ participate in the relationship set $R$. A relationship instance in an ER schema represents an association between the named entities in the real-world enterprise that is being modelled.</p>

<p>The function that an entity plays in a relationship is called that entity&rsquo;s role. Since entity sets participating in a relationship set are generally distinct, roles are distinct and are not usually specified. They are useful when the meaning of a relationship needs clarification.</p>

<p>A relationship may have attributes called <em>descriptive attributes</em>.</p>

<h3 id="attributes">Attributes</h3>

<p>For each attribute, there is a set of permitted values called the domain or the value set. It is akin to the <em>type</em> of the variable.</p>

<h3 id="participation-constraints-and-roles">Participation constraints and roles</h3>

<p>Participation constraints introduce constraints on the entity set within the relationship set. There are two kinds of participation constraints:</p>

<ol>
<li>Partial participation constraint: when &gt;0 of E participates in R.</li>
<li>Total participation constraint: when &gt;=1 of E participates in R.</li>
</ol>

<p>Roles are used when one entity set appears two or more times in a relationship set. For example, an entity set <code>Students</code> may have two tuples playing the role of <code>freshman</code> and <code>sophomore</code> in a relationship set <code>Advised By</code> connected to <code>Professors</code>.</p>

<h3 id="from-the-er-model-to-the-relational-model">From the ER Model to the Relational Model</h3>

<p>There are three rules:</p>

<ol>
<li>An attribute is mapped to one or more attributes with a domain.</li>
<li>An entity set is mapped to a relation. The attributes of the entity set are mapped to the attributes of the relation. The keys are mapped to the primary key of the relation, or to unique combinations of attributes if there is more than one key (to create candidate keys).</li>
<li>A relationship set is mapped to a relation. The attributes of the relationship set are mapped to the attributes of the relation. The keys are also mapped, much like an entity set.</li>
</ol>

<p>However, there are certain minor adjustments that have to be made in the relational model, based on the relationship stated in the ER Model. For example, if we simply apply a primary key constraint to a set of attributes, we are not able to model the &ldquo;at most 1&rdquo; relationship in the ER Model. To do so requires us to use the <code>UNIQUE</code> keyword.</p>

<h4 id="a-more-detailed-explanation">A more detailed explanation</h4>

<p>It is quite simple to implement an entity set in SQL. We just need to know the attributes, the candidate keys (which cannot be <code>null</code>), and the primary key. Then we translate it into a <code>CREATE</code> clause:</p>

<pre><code class="language-sql">CREATE TABLE Professors (
  pid integer,
  name varchar(50),
  dob date,
  PRIMARY KEY (pid));
</code></pre>

<p>For ER diagrams that do not have constraints, this is quite easy. However, there are two different ways of interpreting an ER diagram that has constraints. For example, consider the following ER diagram:</p>

<p><img src="/constraints-er.png" alt="Constraints with Entity-Relationship" /></p>

<p>We can write the SQL in two ways.</p>

<h5 id="method-1-rentedby-as-a-separate-table">Method 1: <code>RentedBy</code> as a separate table</h5>

<pre><code class="language-sql">-- Where Profs and Students have already been created
CREATE TABLE RentedBy (
  sid integer,
  pid integer,
  since date,
  PRIMARY KEY (sid),
  FOREIGN KEY (rid) REFERENCES Profs,
  FOREIGN KEY (sid) REFERENCES Students
);
</code></pre>

<h5 id="method-2-combine-rentedby-and-students">Method 2: combine <code>RentedBy</code> and <code>Students</code></h5>

<pre><code class="language-sql">CREATE TABLE RentedByStudents (
  sid integer PRIMARY KEY,
  name varchar(50),
  dob date,
  rid integer,
  since date,
  FOREIGN KEY rid REFERENCES Rooms
);
</code></pre>

<p>For a relationship set with total constraints, things can get trickier. For example, given the following ER diagram:</p>

<p><img src="/total-constraints-er.png" alt="Total constraints" /></p>

<p>How do we translate the total constraint relationship (one student can rent only one room)? Using a separate <code>RentBy</code> table fails to capture the total participation constraint:</p>

<pre><code class="language-sql">CREATE TABLE RentBy (
  sid integer,
  rid integer,
  since date,
  PRIMARY KEY (sid),
  FOREIGN KEY (sid) REFERENCES Students,
  FOREIGN KEY (rid) REFERENCES Rooms
);
</code></pre>

<p>This happens because we cannot enforce the one-to-one relationship between Students and Rooms. For example, we may have 0 entries for many students, and this would allow for that.</p>

<p>To address this problem, we use the combination <code>RentBy</code> and <code>Students</code> to enforce a one-to-one relationship:</p>

<ol>
<li>There must be every entry for each student.</li>
<li>There must only be one room rented by each student.</li>
</ol>

<p>The implementation is the same as the above example for partial constraint.</p>

<h4 id="roles-in-sql">Roles in SQL</h4>

<p>Given an ER diagram as the following:</p>

<p><img src="/roles-er.png" alt="Roles" /></p>

<p>The corresponding SQL code would be the following.</p>

<pre><code class="language-sql">CREATE TABLE Dorm (
  instalmentID integer,
  lumpsumID integer,
  PRIMARY KEY (instalmentID, lumpsumID),
  FOREIGN KEY (instalmentID) REFERENCES Dorms(id),
  FOREIGN KEY (lumpsumID) REFERENCES Dorms(id)
);
</code></pre>

<p>This example, on hindsight, doesn&rsquo;t really make sense. But you get the idea: we enforce the role using a candidate key of the roles, which both refer back to the primary key.</p>

<h4 id="weak-entity-sets-in-sql">Weak entity sets in SQL</h4>

<p>A weak entity set, we recall, is one that does not have sufficient attributes to form a primary key. It takes a &ldquo;has-a&rdquo; relationship with the dominant entity. For example, the relationship between BookChapters and a Book indicates that the book chapters are weak entity sets.</p>

<pre><code class="language-sql">CREATE TABLE Books (
  isbn char(30) PRIMARY KEY,
  title char(50),
  author char(50)
);

CREATE TABLE BookChapters (
  num char(30),
  title char(50),
  isbn char(30),
  PRIMARY KEY (num, isbn),
  FOREIGN KEY (isbn) REFERENCES Books
    ON DELETE cascade
);
</code></pre>

<h2 id="object-oriented-programming-using-er-diagramming">Object-oriented programming using ER diagramming</h2>

<p>ER diagrams can be used to illustrate object hierarchies. This can be done by reflecting the subclass-superclass relationship and decomposing entity sets into subclasses. It is a special relationship known as the &ldquo;ISA hierarchy&rdquo;. This creates constraints:</p>

<ol>
<li>Overlap constraints: can an entity belong to multiple subclasses? This is satisfied if the entity in the superclass can belong to multiple subclasses.</li>
<li>Covering constraints: does an entity in a superclass have to belong to some subclass? This is satisfied if all the entities in a superclass has to belong to some subclass.</li>
</ol>

<h4 id="differentiating-between-overlapping-and-covering-constraints">Differentiating between overlapping and covering constraints</h4>

<p>Imagine initialising an &ldquo;object&rdquo; from the &ldquo;class&rdquo; (i.e., relation). Think of each relation, for example, as a JSON table.</p>

<ol>
<li>To identify an <strong>overlap constraint</strong>, ask whether that &ldquo;instance&rdquo; can be both X1 and X2 (where X1 and X2 are both subclasses of X)? If the instance can be both X1 and X2, then there is an overlap, i.e., X1 overlaps with X2.</li>
<li>To identify a <strong>covering constraint</strong>, ask whether every &ldquo;instance&rdquo; of either subclass has to be an instance of the master class.</li>
</ol>

<p>The following diagram gives an example:</p>

<p><img src="/er-oop.png" alt="Entity-Relationship as OOP" /></p>

<p>This translates to the following SQL.</p>

<h3 id="approach-1-one-relation-per-subclass-or-superclass">Approach #1: one relation per subclass or superclass</h3>

<pre><code class="language-sql">CREATE TABLE Students (
  sid integer PRIMARY KEY,
  name char(30)
);

CREATE TABLE Undergrads (
  sid integer PRIMARY KEY REFERENCES Students
    ON DELETE CASCADE,
  ged numeric
);

CREATE TABLE Grads (
  sid integer PRIMARY KEY REFERENCES Students
    ON DELETE CASCADE,
  degree varchar(50)
);
</code></pre>

<h3 id="approach-2-one-relation-per-subclass-only">Approach #2: one relation per subclass ONLY</h3>

<p>In this approach, we &ldquo;collapse&rdquo; the superclass of <code>Students</code> into each of the subclasses. <em>This is only applicable if the covering cosntraint is satisfied.</em></p>

<pre><code class="language-sql">CREATE TABLE Undergrads (
  sid integer PRIMARY KEY REFERENCES Students
    ON DELETE CASCADE,
  name varchar(30),
  ged numeric
);

CREATE TABLE Grads (
  sid integer PRIMARY KEY REFERENCES Students
    ON DELETE CASCADE,
  name varchar(30),
  degree varchar(50)
);
</code></pre>

<h2 id="aggregation-using-er-diagrams">Aggregation using ER diagrams</h2>

<p>There are three fundamental principles in OOP: encapsulation, inheritance, and composition. In some ways, the ER model preceded OOP because composition is known as <em>aggregation</em> and can be modelled using SQL as well. For example, if we have a car made up of multiple parts, we can actually model it using ER (or equivalently in OOP).</p>

<h2 id="guidelines-for-er-design">Guidelines for ER design</h2>

<p>The ER diagram should do its best to:</p>

<ol>
<li>Capture as many of the application&rsquo;s constraints as possible.</li>
<li>Not impose any irrelevant constraint that is not required in the application.</li>
</ol>

    </article>
  </section>

  <footer>
    <div>
      <p class="f6 gray mt6 lh-copy">
        
      </p>
    </div>
  </footer>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.14.2/highlight.min.js"></script>

<script>
  hljs.initHighlightingOnLoad();
</script>



  </body>
</html>
